-- FLZ Smart TP Shoot GUI (Always TP Ahead in Target's Direction) + Auto GK + Rejoin Auto-Resume
-- By Flazed

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local VIM = game:GetService("VirtualInputManager")

-- ===== GUI =====
local gui = Instance.new("ScreenGui")
gui.Name = "FLZ_SmartTP_GUI"
gui.ResetOnSpawn = false
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame", gui)
frame.Size = UDim2.new(0, 200, 0, 240)
frame.Position = UDim2.new(0.5, -100, 0.5, -120)
frame.BackgroundTransparency = 0.3
frame.BackgroundColor3 = Color3.new(0,0,0)
frame.Active = true
frame.Draggable = true
frame.Visible = false

local openButton = Instance.new("TextButton", gui)
openButton.Size = UDim2.new(0, 120, 0, 30)
openButton.Position = UDim2.new(0, 20, 0.5, -15)
openButton.Text = "Open TP GUI"
openButton.TextColor3 = Color3.new(1,1,1)
openButton.BackgroundColor3 = Color3.new(0.2,0.2,0.2)
openButton.Font = Enum.Font.GothamBold
openButton.TextScaled = true
openButton.Draggable = true

openButton.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
    openButton.Text = frame.Visible and "Close TP GUI" or "Open TP GUI"
end)

-- GUI Elements
local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 20)
title.Text = "Flazed's AutoTP"
title.TextColor3 = Color3.new(1,1,1)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextScaled = true

local nameBox = Instance.new("TextBox", frame)
nameBox.Size = UDim2.new(0, 180, 0, 24)
nameBox.Position = UDim2.new(0,10,0,25)
nameBox.PlaceholderText = "Enter player name"
nameBox.TextColor3 = Color3.new(1,1,1)
nameBox.BackgroundColor3 = Color3.new(0.2,0.2,0.2)
nameBox.ClearTextOnFocus = true

local toggleButton = Instance.new("TextButton", frame)
toggleButton.Size = UDim2.new(0, 180, 0, 24)
toggleButton.Position = UDim2.new(0,10,0,55)
toggleButton.Text = "TP Shoot Once"
toggleButton.TextColor3 = Color3.new(1,1,1)
toggleButton.BackgroundColor3 = Color3.new(0.3,0.3,0.3)

local autoButton = Instance.new("TextButton", frame)
autoButton.Size = UDim2.new(0, 180, 0, 24)
autoButton.Position = UDim2.new(0,10,0,85)
autoButton.Text = "Auto TP Shoot: OFF"
autoButton.TextColor3 = Color3.new(1,1,1)
autoButton.BackgroundColor3 = Color3.new(0.3,0.3,0.3)

-- Auto GK toggle (spams F every 0.5s when ON)
local gkBtn = Instance.new("TextButton", frame)
gkBtn.Size = UDim2.new(0, 180, 0, 24)
gkBtn.Position = UDim2.new(0,10,0,115)
gkBtn.Text = "Auto GK: OFF"
gkBtn.TextColor3 = Color3.new(1,1,1)
gkBtn.BackgroundColor3 = Color3.new(0.35,0.35,0.35)

local status = Instance.new("TextLabel", frame)
status.Size = UDim2.new(0, 180, 0, 80)
status.Position = UDim2.new(0,10,0,145)
status.Text = "Status: Idle"
status.TextColor3 = Color3.new(1,1,1)
status.BackgroundTransparency = 1
status.TextScaled = true
status.TextWrapped = true

-- ===== Vars =====
local targetPlayer = nil
local autoTP = false
local autoGK = false
local lastShoot = 0

-- Rejoin tracking
local targetQuery = nil         -- substring you typed to find the target
local waitingForTarget = false  -- set when your target leaves

-- ===== Helpers =====
local function charOf(plr) return plr and plr.Character end
local function hrpOf(plr) local c=charOf(plr) return c and (c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Torso")) end
local function humOf(plr) local c=charOf(plr) return c and c:FindFirstChildOfClass("Humanoid") end

local function hasGrappleTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, tool in pairs(char:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("RemoteEvent") then
            return tool
        end
    end
end

local function getPredictedPosition(torso)
    local lpHRP = hrpOf(LocalPlayer)
    if not lpHRP then return torso.Position end
    local vel = torso.AssemblyLinearVelocity
    local dist = (torso.Position - lpHRP.Position).Magnitude
    local predictionTime = math.clamp(dist / 200, 0.05, 1.5)
    return torso.Position + (vel * predictionTime)
end

-- === NEW: Always-ahead leading distance (based on velocity & walk speed)
local function leadDistance(velMag, walkSpeed)
    -- scale with speed; clamp to sane range
    local base = math.clamp(velMag * 0.6, 12, 180)
    -- tiny bump for very fast walkers
    if walkSpeed >= 50 then base = base + 25 end
    if walkSpeed >= 100 then base = base + 45 end
    return base
end

-- === NEW: Always TP in the direction the target is going (no behind mode)
local function tpOnly()
    if not targetPlayer then
        status.Text = "âŒ No target"
        return nil, nil
    end

    local lpChar = LocalPlayer.Character
    local hrp = lpChar and lpChar:FindFirstChild("HumanoidRootPart")
    local tChar = targetPlayer.Character
    local targetHRP = tChar and tChar:FindFirstChild("HumanoidRootPart")
    local targetHum = tChar and tChar:FindFirstChildOfClass("Humanoid")

    if hrp and targetHRP and targetHum then
        local v = targetHRP.AssemblyLinearVelocity
        local velMag = v.Magnitude
        local walkspeed = targetHum.WalkSpeed

        -- forward towards where they're going:
        local forwardDir
        if velMag >= 6 then
            forwardDir = v.Unit
        else
            forwardDir = targetHRP.CFrame.LookVector
        end

        local ahead = leadDistance(velMag, walkspeed)

        -- slightly raise if airborne & moving to avoid clipping
        local liftY = 0
        if targetHum.FloorMaterial == Enum.Material.Air and velMag >= 30 then
            liftY = 2
        end

        -- bias towards predicted position to â€œstickâ€ to path
        local predicted = getPredictedPosition(targetHRP)
        local tpPos = predicted + (forwardDir * ahead) + Vector3.new(0, liftY, 0)

        -- face the same direction theyâ€™re heading
        hrp.CFrame = CFrame.new(tpPos, tpPos + forwardDir)

        status.Text = string.format(
            "âž¡ï¸ Ahead %.0f studs (Walk %.1f | Vel %.1f)",
            ahead, walkspeed, velMag
        )

        -- small shoot delay scales with speed; faster = slightly longer
        local delay = math.clamp(velMag / 400, 0.12, 0.35)
        return ahead, delay
    else
        status.Text = "âŒ Missing HRP or Humanoid"
        return nil, nil
    end
end

local function shootOnly()
    if not targetPlayer then return end
    local tChar = targetPlayer.Character
    local targetHRP = tChar and tChar:FindFirstChild("HumanoidRootPart")
    if targetHRP then
        local tool = hasGrappleTool()
        if tool and tool:FindFirstChild("RemoteEvent") then
            local aimPos = getPredictedPosition(targetHRP)
            tool.RemoteEvent:FireServer(aimPos)
            status.Text = status.Text .. " & Shot"
        end
    end
end

-- ===== Buttons =====
local function acquireTarget(name)
    local lname = name:lower()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and (p.Name:lower():find(lname) or p.DisplayName:lower():find(lname)) then
            return p
        end
    end
end

toggleButton.MouseButton1Click:Connect(function()
    local name = nameBox.Text
    if name == "" then
        status.Text = "âš ï¸ Enter name"
        return
    end
    targetPlayer = acquireTarget(name)
    targetQuery = name:lower()
    waitingForTarget = false

    if not targetPlayer then
        status.Text = "âŒ Target not found"
        return
    end

    status.Text = "âœ… Target: " .. targetPlayer.Name
    local studs, delay = tpOnly()
    if studs and delay then
        task.wait(delay)
        shootOnly()
    end
end)

autoButton.MouseButton1Click:Connect(function()
    if nameBox.Text ~= "" and not targetPlayer then
        targetPlayer = acquireTarget(nameBox.Text)
        if targetPlayer then targetQuery = nameBox.Text:lower() end
    end
    if not targetPlayer then
        status.Text = "âš ï¸ No target for auto"
        return
    end
    autoTP = not autoTP
    autoButton.Text = autoTP and "Auto TP Shoot: ON" or "Auto TP Shoot: OFF"
    lastShoot = tick()
end)

-- ===== GK keysender =====
local function pressFOnce()
    local ok1 = pcall(function()
        StarterGui:SetCore("SendKeyEvent", true, Enum.KeyCode.F, false)
        task.wait(0.05)
        StarterGui:SetCore("SendKeyEvent", false, Enum.KeyCode.F, false)
    end)
    if ok1 then return end
    local ok2 = pcall(function()
        VIM:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        task.wait(0.05)
        VIM:SendKeyEvent(false, Enum.KeyCode.F, false, game)
    end)
    if ok2 then return end
    if typeof(keypress)=="function" and typeof(keyup)=="function" then
        pcall(function() keypress(0x46) task.wait(0.05) keyup(0x46) end)
    end
end

-- Auto GK toggle
gkBtn.MouseButton1Click:Connect(function()
    autoGK = not autoGK
    gkBtn.Text = autoGK and "Auto GK: ON" or "Auto GK: OFF"
    status.Text = autoGK and "â˜ ï¸ Auto GK: spamming F (0.5s)" or "ðŸ›‘ Auto GK: stopped"
end)

-- Auto GK spammer (every 0.5s while ON)
local acc = 0
RunService.Heartbeat:Connect(function(dt)
    if autoGK then
        acc += dt
        if acc >= 0.5 then
            pressFOnce()
            acc = 0
        end
    else
        acc = 0
    end
end)

-- ===== Rejoin auto-resume: re-acquire target & turn Auto TP ON
Players.PlayerRemoving:Connect(function(plr)
    if targetPlayer and plr == targetPlayer then
        waitingForTarget = true
        status.Text = "â³ "..plr.Name.." left. Waiting to rejoinâ€¦"
        targetPlayer = nil
    end
end)

Players.PlayerAdded:Connect(function(plr)
    if waitingForTarget and targetQuery then
        local q = targetQuery
        local match = (plr.Name:lower():find(q) ~= nil) or (plr.DisplayName:lower():find(q) ~= nil)
        if match then
            targetPlayer = plr
            waitingForTarget = false
            autoTP = true
            autoButton.Text = "Auto TP Shoot: ON"
            lastShoot = 0
            status.Text = "âœ… "..plr.Name.." rejoined â€” Auto TP ON"
        end
    end
end)

-- ===== Auto loop =====
RunService.RenderStepped:Connect(function()
    if autoTP and targetPlayer then
        local studs, delay = tpOnly()
        if studs and (tick() - lastShoot >= (delay or 0.2)) then
            shootOnly()
            lastShoot = tick()
        end
    end
end)
