-- FLZ Smart TP Shoot GUI (Front by default; Behind ONLY when flying/zooming) + Auto GK + Rejoin Auto-Resume
-- By Flazed

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local VIM = game:GetService("VirtualInputManager")

-- ===== GUI =====
local gui = Instance.new("ScreenGui")
gui.Name = "FLZ_SmartTP_GUI"
gui.ResetOnSpawn = false
gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame", gui)
frame.Size = UDim2.new(0, 200, 0, 240)
frame.Position = UDim2.new(0.5, -100, 0.5, -120)
frame.BackgroundTransparency = 0.3
frame.BackgroundColor3 = Color3.new(0,0,0)
frame.Active = true
frame.Draggable = true
frame.Visible = false

local openButton = Instance.new("TextButton", gui)
openButton.Size = UDim2.new(0, 120, 0, 30)
openButton.Position = UDim2.new(0, 20, 0.5, -15)
openButton.Text = "Open TP GUI"
openButton.TextColor3 = Color3.new(1,1,1)
openButton.BackgroundColor3 = Color3.new(0.2,0.2,0.2)
openButton.Font = Enum.Font.GothamBold
openButton.TextScaled = true
openButton.Draggable = true

openButton.MouseButton1Click:Connect(function()
    frame.Visible = not frame.Visible
    openButton.Text = frame.Visible and "Close TP GUI" or "Open TP GUI"
end)

-- GUI Elements
local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 20)
title.Text = "Flazed's And Live's AutoTP"
title.TextColor3 = Color3.new(1,1,1)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextScaled = true

local nameBox = Instance.new("TextBox", frame)
nameBox.Size = UDim2.new(0, 180, 0, 24)
nameBox.Position = UDim2.new(0,10,0,25)
nameBox.PlaceholderText = "Enter player name"
nameBox.TextColor3 = Color3.new(1,1,1)
nameBox.BackgroundColor3 = Color3.new(0.2,0.2,0.2)
nameBox.ClearTextOnFocus = true

local toggleButton = Instance.new("TextButton", frame)
toggleButton.Size = UDim2.new(0, 180, 0, 24)
toggleButton.Position = UDim2.new(0,10,0,55)
toggleButton.Text = "TP Shoot Once"
toggleButton.TextColor3 = Color3.new(1,1,1)
toggleButton.BackgroundColor3 = Color3.new(0.3,0.3,0.3)

local autoButton = Instance.new("TextButton", frame)
autoButton.Size = UDim2.new(0, 180, 0, 24)
autoButton.Position = UDim2.new(0,10,0,85)
autoButton.Text = "Auto TP Shoot: OFF"
autoButton.TextColor3 = Color3.new(1,1,1)
autoButton.BackgroundColor3 = Color3.new(0.3,0.3,0.3)

-- Auto GK toggle (spams F every 0.5s when ON)
local gkBtn = Instance.new("TextButton", frame)
gkBtn.Size = UDim2.new(0, 180, 0, 24)
gkBtn.Position = UDim2.new(0,10,0,115)
gkBtn.Text = "Auto GK: OFF"
gkBtn.TextColor3 = Color3.new(1,1,1)
gkBtn.BackgroundColor3 = Color3.new(0.35,0.35,0.35)

local status = Instance.new("TextLabel", frame)
status.Size = UDim2.new(0, 180, 0, 80)
status.Position = UDim2.new(0,10,0,145)
status.Text = "Status: Idle"
status.TextColor3 = Color3.new(1,1,1)
status.BackgroundTransparency = 1
status.TextScaled = true
status.TextWrapped = true

-- ===== Vars =====
local targetPlayer = nil
local autoTP = false
local autoGK = false
local lastShoot = 0

-- Rejoin tracking
local targetQuery = nil         -- substring you typed to find the target
local waitingForTarget = false  -- set when your target leaves

-- ===== Helpers =====
local function charOf(plr) return plr and plr.Character end
local function hrpOf(plr) local c=charOf(plr) return c and (c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Torso")) end
local function humOf(plr) local c=charOf(plr) return c and c:FindFirstChildOfClass("Humanoid") end

local function hasGrappleTool()
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, tool in pairs(char:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("RemoteEvent") then
            return tool
        end
    end
end

local function getPredictedPosition(torso)
    local lpHRP = hrpOf(LocalPlayer)
    if not lpHRP then return torso.Position end
    local vel = torso.AssemblyLinearVelocity
    local dist = (torso.Position - lpHRP.Position).Magnitude
    local predictionTime = math.clamp(dist / 200, 0.05, 1.5)
    return torso.Position + (vel * predictionTime)
end

-- front/behind spacing based on speed; front by default
local function chooseStuds(walkspeed, velocitySpeed)
    local extra = math.clamp(velocitySpeed / 2, 0, 100)
    if walkspeed == 16 then
        return math.random(8,15) + extra, 0.15
    elseif walkspeed == 50 then
        return math.random(60,120) + extra, 0.20
    elseif walkspeed == 100 then
        return math.random(140,190) + extra, 0.33
    else
        return math.random(40,80) + extra, 0.20
    end
end

local function pressFOnce()
    local ok1 = pcall(function()
        StarterGui:SetCore("SendKeyEvent", true, Enum.KeyCode.F, false)
        task.wait(0.05)
        StarterGui:SetCore("SendKeyEvent", false, Enum.KeyCode.F, false)
    end)
    if ok1 then return end
    local ok2 = pcall(function()
        VIM:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        task.wait(0.05)
        VIM:SendKeyEvent(false, Enum.KeyCode.F, false, game)
    end)
    if ok2 then return end
    if typeof(keypress)=="function" and typeof(keyup)=="function" then
        pcall(function() keypress(0x46) task.wait(0.05) keyup(0x46) end)
    end
end

-- ===== Detect “flying/zooming” (STRICT so front is used most of the time)
local function isFlyingOrZooming(targetHum, targetHRP)
    if not (targetHum and targetHRP) then return false end
    local v = targetHRP.AssemblyLinearVelocity
    local speed = v.Magnitude

    -- stricter thresholds to avoid always-behind:
    local veryFast = speed >= 120         -- truly zooming/launched
    local bigVertical = math.abs(v.Y) >= 28
    local airborne = (targetHum.FloorMaterial == Enum.Material.Air)

    -- only treat airborne as "flying" if they're actually moving notably
    local airborneMoving = airborne and (speed >= 45)

    return veryFast or bigVertical or airborneMoving
end

-- ===== TP logic (Front by default; Behind only when flying/zooming)
local function tpOnly()
    if not targetPlayer then
        status.Text = "❌ No target"
        return nil, nil
    end

    local lpChar = LocalPlayer.Character
    local hrp = lpChar and lpChar:FindFirstChild("HumanoidRootPart")
    local tChar = targetPlayer.Character
    local targetHRP = tChar and tChar:FindFirstChild("HumanoidRootPart")
    local targetHum = tChar and tChar:FindFirstChildOfClass("Humanoid")

    if hrp and targetHRP and targetHum then
        local v = targetHRP.AssemblyLinearVelocity
        local speed = v.Magnitude
        local walkspeed = targetHum.WalkSpeed

        local offset, delay = chooseStuds(walkspeed, speed)

        local goBehind = isFlyingOrZooming(targetHum, targetHRP) -- STRICT condition
        local dir = (goBehind and -1 or 1) * targetHRP.CFrame.LookVector

        local tpPos = targetHRP.Position + (dir * offset)
        if goBehind then
            -- slight lift to avoid clipping when they’re airborne
            tpPos += Vector3.new(0, 2.5, 0)
        end

        hrp.CFrame = CFrame.new(tpPos, targetHRP.Position)

        status.Text = string.format(
            "%s TP'd %.0f studs (%s | Walk %.1f | Vel %.1f)",
            goBehind and "🛩️ Behind" or "➡️ Front",
            offset,
            goBehind and "flying/zooming" or "normal",
            walkspeed, speed
        )

        return offset, delay
    else
        status.Text = "❌ Missing HRP or Humanoid"
        return nil, nil
    end
end

local function shootOnly()
    if not targetPlayer then return end
    local tChar = targetPlayer.Character
    local targetHRP = tChar and tChar:FindFirstChild("HumanoidRootPart")
    if targetHRP then
        local tool = hasGrappleTool()
        if tool and tool:FindFirstChild("RemoteEvent") then
            local aimPos = getPredictedPosition(targetHRP)
            tool.RemoteEvent:FireServer(aimPos)
            status.Text = status.Text .. " & Shot"
        end
    end
end

-- ===== Buttons =====
local function acquireTarget(name)
    local lname = name:lower()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and (p.Name:lower():find(lname) or p.DisplayName:lower():find(lname)) then
            return p
        end
    end
end

toggleButton.MouseButton1Click:Connect(function()
    local name = nameBox.Text
    if name == "" then
        status.Text = "⚠️ Enter name"
        return
    end
    targetPlayer = acquireTarget(name)
    targetQuery = name:lower()
    waitingForTarget = false

    if not targetPlayer then
        status.Text = "❌ Target not found"
        return
    end

    status.Text = "✅ Target: " .. targetPlayer.Name
    local studs, delay = tpOnly()
    if studs and delay then
        task.wait(delay)
        shootOnly()
    end
end)

autoButton.MouseButton1Click:Connect(function()
    if nameBox.Text ~= "" and not targetPlayer then
        targetPlayer = acquireTarget(nameBox.Text)
        if targetPlayer then targetQuery = nameBox.Text:lower() end
    end
    if not targetPlayer then
        status.Text = "⚠️ No target for auto"
        return
    end
    autoTP = not autoTP
    autoButton.Text = autoTP and "Auto TP Shoot: ON" or "Auto TP Shoot: OFF"
    lastShoot = tick()
end)

-- Auto GK toggle
gkBtn.MouseButton1Click:Connect(function()
    autoGK = not autoGK
    gkBtn.Text = autoGK and "Auto GK: ON" or "Auto GK: OFF"
    status.Text = autoGK and "☠️ Auto GK: spamming F (0.5s)" or "🛑 Auto GK: stopped"
end)

-- Auto GK spammer (every 0.5s while ON)
local acc = 0
RunService.Heartbeat:Connect(function(dt)
    if autoGK then
        acc += dt
        if acc >= 0.5 then
            pressFOnce()
            acc = 0
        end
    else
        acc = 0
    end
end)

-- ===== Rejoin auto-resume: re-acquire target & turn Auto TP ON
Players.PlayerRemoving:Connect(function(plr)
    if targetPlayer and plr == targetPlayer then
        waitingForTarget = true
        status.Text = "⏳ "..plr.Name.." left. Waiting to rejoin…"
        targetPlayer = nil
    end
end)

Players.PlayerAdded:Connect(function(plr)
    if waitingForTarget and targetQuery then
        local q = targetQuery
        local match = (plr.Name:lower():find(q) ~= nil) or (plr.DisplayName:lower():find(q) ~= nil)
        if match then
            targetPlayer = plr
            waitingForTarget = false
            autoTP = true
            autoButton.Text = "Auto TP Shoot: ON"
            lastShoot = 0
            status.Text = "✅ "..plr.Name.." rejoined — Auto TP ON"
        end
    end
end)

-- ===== Auto loop =====
RunService.RenderStepped:Connect(function()
    if autoTP and targetPlayer then
        local studs, delay = tpOnly()
        if studs and (tick() - lastShoot >= (delay or 0.2)) then
            shootOnly()
            lastShoot = tick()
        end
    end
end)
